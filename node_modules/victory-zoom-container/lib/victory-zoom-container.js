"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useVictoryZoomContainer = exports.VictoryZoomContainer = exports.VICTORY_ZOOM_CONTAINER_DEFAULT_PROPS = void 0;
var _react = _interopRequireDefault(require("react"));
var _zoomHelpers = require("./zoom-helpers");
var _victoryCore = require("victory-core");
var _defaults = _interopRequireDefault(require("lodash/defaults"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_DOWNSAMPLE = 150;
const VICTORY_ZOOM_CONTAINER_DEFAULT_PROPS = exports.VICTORY_ZOOM_CONTAINER_DEFAULT_PROPS = {
  clipContainerComponent: /*#__PURE__*/_react.default.createElement(_victoryCore.VictoryClipContainer, null),
  allowPan: true,
  allowZoom: true,
  zoomActive: false
};
const useVictoryZoomContainer = initialProps => {
  const props = {
    ...VICTORY_ZOOM_CONTAINER_DEFAULT_PROPS,
    ...initialProps
  };
  const {
    children,
    currentDomain,
    zoomActive,
    allowZoom,
    downsample,
    scale,
    clipContainerComponent,
    polar,
    origin,
    horizontal
  } = props;
  const downsampleZoomData = (child, domain) => {
    const getData = childProps => {
      const {
        data,
        x,
        y
      } = childProps;
      const defaultGetData = child.type && typeof child.type.getData === "function" ? child.type.getData : () => undefined;
      // skip costly data formatting if x and y accessors are not present
      return Array.isArray(data) && !x && !y ? data : defaultGetData(childProps);
    };
    const data = getData(child.props);

    // return undefined if downsample is not run, then default() will replace with child.props.data
    if (!downsample || !domain || !data) {
      return undefined;
    }
    const maxPoints = downsample === true ? DEFAULT_DOWNSAMPLE : downsample;
    const dimension = props.zoomDimension || "x";

    // important: assumes data is ordered by dimension
    // get the start and end of the data that is in the current visible domain
    let startIndex = data.findIndex(d => d[dimension] >= domain[dimension][0]);
    let endIndex = data.findIndex(d => d[dimension] > domain[dimension][1]);
    // pick one more point (if available) at each end so that VictoryLine, VictoryArea connect
    if (startIndex !== 0) {
      startIndex -= 1;
    }
    if (endIndex !== -1) {
      endIndex += 1;
    }
    const visibleData = data.slice(startIndex, endIndex);
    return _victoryCore.Data.downsample(visibleData, maxPoints, startIndex);
  };
  const modifiedChildren = _react.default.Children.toArray(children).map(child => {
    const role = child.type && child.type.role;
    const isDataComponent = _victoryCore.Data.isDataComponent(child);
    const originalDomain = (0, _defaults.default)({}, props.originalDomain, props.domain);
    const zoomDomain = (0, _defaults.default)({}, props.zoomDomain, props.domain);
    const cachedZoomDomain = (0, _defaults.default)({}, props.cachedZoomDomain, props.domain);
    let domain;
    if (!_zoomHelpers.ZoomHelpers.checkDomainEquality(zoomDomain, cachedZoomDomain)) {
      // if zoomDomain has been changed, use it
      domain = zoomDomain;
    } else if (allowZoom && !zoomActive) {
      // if user has zoomed all the way out, use the child domain
      domain = child.props.domain;
    } else {
      // default: use currentDomain, set by the event handlers
      domain = (0, _defaults.default)({}, currentDomain, originalDomain);
    }
    let newDomain = props.polar ? {
      x: originalDomain.x,
      y: [0, domain.y[1]]
    } : domain;
    if (newDomain && props.zoomDimension) {
      // if zooming is restricted to a dimension, don't squash changes to zoomDomain in other dim
      newDomain = {
        ...zoomDomain,
        [props.zoomDimension]: newDomain[props.zoomDimension]
      };
    }

    // don't downsample stacked data
    const childProps = isDataComponent && role !== "stack" ? {
      domain: newDomain,
      data: downsampleZoomData(child, newDomain)
    } : {
      domain: newDomain
    };
    const newChild = /*#__PURE__*/_react.default.cloneElement(child, (0, _defaults.default)(childProps, child.props));

    // Clip data components
    if (_victoryCore.Data.isDataComponent(newChild)) {
      const rangeX = horizontal ? scale.y.range() : scale.x.range();
      const rangeY = horizontal ? scale.x.range() : scale.y.range();
      const plottableWidth = Math.abs(rangeX[0] - rangeX[1]);
      const plottableHeight = Math.abs(rangeY[0] - rangeY[1]);
      const radius = Math.max(...rangeY);
      const groupComponent = /*#__PURE__*/_react.default.cloneElement(clipContainerComponent, {
        clipWidth: plottableWidth,
        clipHeight: plottableHeight,
        translateX: Math.min(...rangeX),
        translateY: Math.min(...rangeY),
        polar,
        origin: polar ? origin : undefined,
        radius: polar ? radius : undefined,
        ...clipContainerComponent.props
      });
      return /*#__PURE__*/_react.default.cloneElement(newChild, {
        groupComponent
      });
    }
    return newChild;
  });
  return {
    props,
    children: modifiedChildren
  };
};
exports.useVictoryZoomContainer = useVictoryZoomContainer;
const VictoryZoomContainer = initialProps => {
  const {
    props,
    children
  } = useVictoryZoomContainer(initialProps);
  return /*#__PURE__*/_react.default.createElement(_victoryCore.VictoryContainer, props, children);
};
exports.VictoryZoomContainer = VictoryZoomContainer;
VictoryZoomContainer.role = "container";
VictoryZoomContainer.defaultEvents = initialProps => {
  const props = {
    ...VICTORY_ZOOM_CONTAINER_DEFAULT_PROPS,
    ...initialProps
  };
  const createEventHandler = (handler, disabled) =>
  // eslint-disable-next-line max-params
  (event, targetProps, eventKey, context) => disabled || props.disable ? {} : handler(event, {
    ...props,
    ...targetProps
  }, eventKey, context);
  return [{
    target: "parent",
    eventHandlers: {
      onMouseDown: createEventHandler(_zoomHelpers.ZoomHelpers.onMouseDown),
      onTouchStart: createEventHandler(_zoomHelpers.ZoomHelpers.onMouseDown),
      onMouseUp: createEventHandler(_zoomHelpers.ZoomHelpers.onMouseUp),
      onTouchEnd: createEventHandler(_zoomHelpers.ZoomHelpers.onMouseUp),
      onMouseLeave: createEventHandler(_zoomHelpers.ZoomHelpers.onMouseLeave),
      onTouchCancel: createEventHandler(_zoomHelpers.ZoomHelpers.onMouseLeave),
      onMouseMove: createEventHandler(_zoomHelpers.ZoomHelpers.onMouseMove),
      onTouchMove: createEventHandler(_zoomHelpers.ZoomHelpers.onMouseMove),
      onWheel: createEventHandler(_zoomHelpers.ZoomHelpers.onWheel, !props.allowZoom)
    }
  }];
};