function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
import React, { useEffect, useCallback, useMemo, forwardRef, useRef } from "react";
import { SkiaDomView } from "../views";
import { SkiaRoot } from "./Reconciler";
export const useCanvasRef = () => useRef(null);
const useOnSizeEvent = (resultValue, onLayout) => {
  return useCallback(event => {
    if (onLayout) {
      onLayout(event);
    }
    const {
      width,
      height
    } = event.nativeEvent.layout;
    if (resultValue) {
      resultValue.value = {
        width,
        height
      };
    }
  }, [onLayout, resultValue]);
};
export const CanvasOld = /*#__PURE__*/forwardRef(({
  children,
  style,
  debug,
  mode = "default",
  onSize: _onSize,
  onLayout: _onLayout,
  ...props
}, forwardedRef) => {
  const onLayout = useOnSizeEvent(_onSize, _onLayout);
  const innerRef = useCanvasRef();
  const ref = useCombinedRefs(forwardedRef, innerRef);
  const redraw = useCallback(() => {
    var _innerRef$current;
    (_innerRef$current = innerRef.current) === null || _innerRef$current === void 0 || _innerRef$current.redraw();
  }, [innerRef]);
  const getNativeId = useCallback(() => {
    var _innerRef$current$nat, _innerRef$current2;
    const id = (_innerRef$current$nat = (_innerRef$current2 = innerRef.current) === null || _innerRef$current2 === void 0 ? void 0 : _innerRef$current2.nativeId) !== null && _innerRef$current$nat !== void 0 ? _innerRef$current$nat : -1;
    return id;
  }, [innerRef]);
  const root = useMemo(() => new SkiaRoot(redraw, getNativeId), [redraw, getNativeId]);

  // Render effect
  useEffect(() => {
    root.render(children);
  }, [children, root, redraw]);
  useEffect(() => {
    return () => {
      root.unmount();
    };
  }, [root]);
  return /*#__PURE__*/React.createElement(SkiaDomView, _extends({
    ref: ref,
    style: style,
    root: root.dom,
    onLayout: onLayout,
    debug: debug,
    mode: mode
  }, props));
});

/**
 * Combines a list of refs into a single ref. This can be used to provide
 * both a forwarded ref and an internal ref keeping the same functionality
 * on both of the refs.
 * @param refs Array of refs to combine
 * @returns A single ref that can be used in a ref prop.
 */
const useCombinedRefs = (...refs) => {
  const targetRef = React.useRef(null);
  React.useEffect(() => {
    refs.forEach(ref => {
      if (ref) {
        if (typeof ref === "function") {
          ref(targetRef.current);
        } else {
          ref.current = targetRef.current;
        }
      }
    });
  }, [refs]);
  return targetRef;
};
//# sourceMappingURL=CanvasOld.js.map